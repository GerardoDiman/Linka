// Cliente API que usa nuestro backend serverless integrado
// El usuario solo necesita su token de Notion

// Determinar la URL base de la API seg√∫n el entorno
const getApiBase = () => {
  if (typeof window !== 'undefined') {
    console.log('üîç Detectando entorno:', {
      hostname: window.location.hostname,
      port: window.location.port,
      origin: window.location.origin
    })
    
    // En desarrollo local, SIEMPRE usar servidor proxy
    if (window.location.hostname === 'localhost') {
      const devApiBase = 'http://localhost:3003/notion'
      console.log('üèóÔ∏è Usando API de desarrollo:', devApiBase)
      return devApiBase
    }
    // En producci√≥n, usar funciones serverless integradas
    return window.location.origin + '/api'
  }
  // Fallback para SSR
  return '/api'
}

const API_BASE = getApiBase()

interface ApiError {
  error: string
  details?: string
  success?: boolean
}

export class NotionApiClient {
  private token: string

  constructor(token: string) {
    this.token = token
  }

  private async makeRequest(endpoint: string, options: RequestInit = {}): Promise<any> {
    const url = `${API_BASE}${endpoint}`
    
    console.log(`üîó Making request to: ${url}`)
    
    const defaultHeaders = {
      'Authorization': `Bearer ${this.token}`,
      'Content-Type': 'application/json'
    }

    const config: RequestInit = {
      ...options,
      headers: {
        ...defaultHeaders,
        ...options.headers,
      },
      mode: 'cors'
    }

    console.log('üìã Request config:', {
      url,
      method: config.method || 'GET'
    })

    try {
      const response = await fetch(url, config)
      
      console.log(`üìä Response status: ${response.status}`)
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ 
          error: `HTTP ${response.status}: ${response.statusText}` 
        })) as ApiError
        
        console.error('‚ùå Error response:', errorData)
        
        // Crear mensajes de error m√°s descriptivos basados en el status
        let errorMessage = errorData.error || 'Error desconocido'
        
        if (response.status === 401) {
          errorMessage = 'Token inv√°lido o sin permisos. Verifica que el token sea correcto y est√© activo.'
        } else if (response.status === 403) {
          errorMessage = 'Sin permisos para acceder a los recursos. Aseg√∫rate de haber compartido las bases de datos con tu integraci√≥n.'
        } else if (response.status === 429) {
          errorMessage = 'L√≠mite de requests excedido. Intenta de nuevo en unos segundos.'
        } else if (errorData.details) {
          errorMessage = `${errorData.error}: ${errorData.details}`
        }
        
        throw new Error(errorMessage)
      }

      const data = await response.json()
      console.log('‚úÖ Response successful:', {
        type: data.type,
        resultsCount: data.results?.length || 0,
        hasMore: data.has_more
      })
      return data
      
    } catch (error) {
      console.error('üí• Request failed:', error)
      
      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new Error('Error de conexi√≥n: No se pudo conectar con el servidor. Verifica tu conexi√≥n a internet.')
      }
      
      // Si ya es un Error personalizado, re-lanzarlo
      if (error instanceof Error) {
        throw error
      }
      
      throw new Error('Error desconocido al procesar la solicitud')
    }
  }

  async search(query: any = {}): Promise<any> {
    console.log('üîç Searching databases...')
    // Nuestro backend maneja la b√∫squeda autom√°ticamente
    return this.makeRequest('/databases')
  }

  async getDatabase(databaseId: string): Promise<any> {
    console.log(`üìñ Getting database: ${databaseId}`)
    return this.makeRequest(`/databases/${databaseId}`)
  }

  async testConnection(): Promise<boolean> {
    try {
      console.log('üß™ Testing connection to Notion via our backend...')
      const response = await this.makeRequest('/test-connection')
      
      const isValid = response && response.success === true
      console.log('üéØ Connection test result:', isValid ? 'SUCCESS' : 'FAILED')
      return isValid
    } catch (error) {
      console.error('üö´ Connection test failed:', error)
      return false
    }
  }

  // M√©todo adicional para obtener informaci√≥n del bot/integraci√≥n
  async getBotInfo(): Promise<any> {
    try {
      const response = await this.makeRequest('/test-connection')
      return response.bot || null
    } catch (error) {
      console.error('Error getting bot info:', error)
      return null
    }
  }
} 